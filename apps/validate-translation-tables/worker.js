/* global mergeData, validateMappings, detectMissingMappings, generateSummaryStats, normalizeKeyValue, calculateNameSimilarity, isHighConfidenceNameMatch, statesMatch, countriesMatch */
importScripts('validation.js');

const WORKER_NAME_MATCH_AMBIGUITY_GAP = 0.03;
const PROGRESS_MIN_INTERVAL_MS = 400;
const progressState = {};

function reportProgress(stage, processed, total) {
    const now = Date.now();
    const last = progressState[stage] || 0;
    if (processed === 0 || processed === total || now - last >= PROGRESS_MIN_INTERVAL_MS) {
        self.postMessage({ type: 'progress', stage, processed, total });
        progressState[stage] = now;
    }
}

function buildKeyValueMap(rows, keyField) {
    const map = new Map();
    rows.forEach(row => {
        const raw = row[keyField];
        const normalized = normalizeKeyValue(raw);
        if (!normalized) {
            return;
        }
        if (!map.has(normalized)) {
            map.set(normalized, row);
        }
    });
    return map;
}

function resolveLocationValue(row, fieldName) {
    if (!row || !fieldName) return '';
    return row[fieldName] ?? '';
}

function buildLocationContext(row, locationFields) {
    return {
        state: resolveLocationValue(row, locationFields.state),
        city: resolveLocationValue(row, locationFields.city),
        country: resolveLocationValue(row, locationFields.country)
    };
}

function hasLocationSignal(context) {
    return Boolean(context.state || context.city || context.country);
}

function hasComparableState(state1, state2) {
    const normalized1 = String(state1 || '').trim().toLowerCase();
    const normalized2 = String(state2 || '').trim().toLowerCase();
    return Boolean(normalized1 && normalized2 && normalized1 !== 'ot' && normalized2 !== 'ot');
}

function shouldBlockByLocation(sourceContext, targetContext) {
    if (
        sourceContext.country && targetContext.country &&
        !countriesMatch(sourceContext.country, targetContext.country)
    ) {
        return true;
    }

    if (
        hasComparableState(sourceContext.state, targetContext.state) &&
        sourceContext.country &&
        targetContext.country &&
        countriesMatch(sourceContext.country, targetContext.country) &&
        !statesMatch(sourceContext.state, targetContext.state)
    ) {
        return true;
    }

    return false;
}

function passesNameGate(sourceName, targetName, sourceContext, targetContext, score, threshold) {
    const hasContext = hasLocationSignal(sourceContext) || hasLocationSignal(targetContext);
    const highConfidence = isHighConfidenceNameMatch(
        sourceName,
        targetName,
        sourceContext.state,
        targetContext.state,
        sourceContext.city,
        targetContext.city,
        sourceContext.country,
        targetContext.country,
        score,
        threshold
    );
    if (highConfidence) {
        return true;
    }
    if (score < threshold) {
        return false;
    }
    if (!hasContext) {
        return true;
    }

    const strictScore = Math.max(0.9, threshold + 0.08);
    return score >= strictScore;
}

function findBestNameMatch(
    sourceRow,
    sourceNameField,
    sourceLocationFields,
    targetEntries,
    targetNameField,
    targetLocationFields,
    threshold,
    usedKeys,
    minGap = WORKER_NAME_MATCH_AMBIGUITY_GAP
) {
    const sourceName = sourceRow?.[sourceNameField];
    if (!sourceName) return null;
    const sourceContext = buildLocationContext(sourceRow, sourceLocationFields);
    let best = null;
    let bestScore = -1;
    let secondBestScore = -1;
    targetEntries.forEach(({ key, row }) => {
        if (usedKeys.has(key)) return;
        const targetName = row[targetNameField];
        if (!targetName) return;
        const targetContext = buildLocationContext(row, targetLocationFields);
        if (shouldBlockByLocation(sourceContext, targetContext)) return;
        const score = calculateNameSimilarity(sourceName, targetName);
        if (!passesNameGate(sourceName, targetName, sourceContext, targetContext, score, threshold)) {
            return;
        }
        if (score > bestScore) {
            secondBestScore = bestScore;
            bestScore = score;
            best = { key, row, score };
        } else if (score > secondBestScore) {
            secondBestScore = score;
        }
    });
    if (!best) {
        return null;
    }
    const effectiveGap = bestScore >= 0.9 ? minGap : (minGap + 0.01);
    if (secondBestScore >= 0 && bestScore - secondBestScore < effectiveGap) {
        return {
            ambiguous: true,
            bestScore,
            secondBestScore,
            candidate: best
        };
    }
    return best;
}

function collectTopNameCandidates(
    sourceRows,
    targetRows,
    sourceNameField,
    targetNameField,
    sourceLocationFields,
    targetLocationFields,
    threshold,
    maxPerSource = 3,
    minGap = WORKER_NAME_MATCH_AMBIGUITY_GAP,
    onProgress = null
) {
    const candidates = [];
    const ambiguousSources = new Set();

    sourceRows.forEach((sourceRow, sourceIndex) => {
        if (onProgress) {
            onProgress(sourceIndex + 1, sourceRows.length);
        }
        const sourceName = sourceRow[sourceNameField];
        if (!sourceName) {
            return;
        }
        const sourceContext = buildLocationContext(sourceRow, sourceLocationFields);

        const topMatches = [];
        targetRows.forEach((targetRow, targetIndex) => {
            const targetName = targetRow[targetNameField];
            if (!targetName) {
                return;
            }
            const targetContext = buildLocationContext(targetRow, targetLocationFields);
            if (shouldBlockByLocation(sourceContext, targetContext)) {
                return;
            }
            const score = calculateNameSimilarity(sourceName, targetName);
            if (!passesNameGate(sourceName, targetName, sourceContext, targetContext, score, threshold)) {
                return;
            }

            topMatches.push({ sourceIndex, targetIndex, score });
            topMatches.sort((a, b) => b.score - a.score);
            if (topMatches.length > maxPerSource) {
                topMatches.pop();
            }
        });

        const effectiveGap = topMatches[0]?.score >= 0.9 ? minGap : (minGap + 0.01);
        if (
            topMatches.length > 1 &&
            (topMatches[0].score - topMatches[1].score) < effectiveGap
        ) {
            ambiguousSources.add(sourceIndex);
            return;
        }
        topMatches.forEach(match => candidates.push(match));
    });

    candidates.sort(
        (a, b) => b.score - a.score || a.sourceIndex - b.sourceIndex || a.targetIndex - b.targetIndex
    );
    return { candidates, ambiguousSources };
}

function assignGlobalNameMatches(
    sourceRows,
    targetRows,
    sourceNameField,
    targetNameField,
    sourceLocationFields,
    targetLocationFields,
    threshold,
    minGap = WORKER_NAME_MATCH_AMBIGUITY_GAP,
    onProgress = null
) {
    const { candidates, ambiguousSources } = collectTopNameCandidates(
        sourceRows,
        targetRows,
        sourceNameField,
        targetNameField,
        sourceLocationFields,
        targetLocationFields,
        threshold,
        4,
        minGap,
        onProgress
    );

    const matchesBySource = new Map();
    const usedTargets = new Set();

    candidates.forEach(candidate => {
        if (matchesBySource.has(candidate.sourceIndex)) {
            return;
        }
        if (usedTargets.has(candidate.targetIndex)) {
            return;
        }
        matchesBySource.set(candidate.sourceIndex, {
            targetIndex: candidate.targetIndex,
            score: candidate.score
        });
        usedTargets.add(candidate.targetIndex);
    });

    return { matchesBySource, usedTargets, ambiguousSources };
}

function generateTranslationTableWorker(outcomes, wsuOrg, keyConfig, nameCompare, options, selectedColumns, keyLabels) {
    const nameCompareEnabled = Boolean(nameCompare.enabled);
    const outcomesNameField = nameCompare.outcomes_column || '';
    const wsuNameField = nameCompare.wsu_column || '';
    const threshold = typeof nameCompare.threshold === 'number' ? nameCompare.threshold : 0.8;
    const ambiguityGap = typeof nameCompare.ambiguity_gap === 'number'
        ? nameCompare.ambiguity_gap
        : WORKER_NAME_MATCH_AMBIGUITY_GAP;
    const outcomesLocationFields = {
        state: nameCompare.state_outcomes || '',
        city: nameCompare.city_outcomes || '',
        country: nameCompare.country_outcomes || ''
    };
    const wsuLocationFields = {
        state: nameCompare.state_wsu || '',
        city: nameCompare.city_wsu || '',
        country: nameCompare.country_wsu || ''
    };
    const canNameMatch = nameCompareEnabled && outcomesNameField && wsuNameField;
    const forceNameMatch = Boolean(options.forceNameMatch);

    const headerLabels = {
        input: keyLabels.outcomes || outcomesNameField || 'Outcomes Key',
        output: keyLabels.wsu || wsuNameField || 'myWSU Key'
    };

    const cleanRows = [];
    const errorRows = [];

    if (forceNameMatch || !keyConfig.outcomes || !keyConfig.wsu) {
        if (!canNameMatch) {
            return { cleanRows, errorRows, selectedColumns, headerLabels };
        }

        reportProgress('match_candidates', 0, outcomes.length);
        const { matchesBySource, usedTargets, ambiguousSources } = assignGlobalNameMatches(
            outcomes,
            wsuOrg,
            outcomesNameField,
            wsuNameField,
            outcomesLocationFields,
            wsuLocationFields,
            threshold,
            ambiguityGap,
            (processed, total) => reportProgress('match_candidates', processed, total)
        );

        const totalRows = outcomes.length + wsuOrg.length;
        let processedRows = 0;
        outcomes.forEach((outcomesRow, outcomesIndex) => {
            const match = matchesBySource.get(outcomesIndex);
            const wsuRow = match ? wsuOrg[match.targetIndex] : null;
            processedRows += 1;
            reportProgress('build_rows', processedRows, totalRows);

            if (wsuRow) {
                const rowData = {};
                rowData.match_similarity = match
                    ? Math.round(match.score * 1000) / 10
                    : '';
                selectedColumns.outcomes.forEach(col => {
                    rowData[`outcomes_${col}`] = outcomesRow[col] ?? '';
                });
                selectedColumns.wsu_org.forEach(col => {
                    rowData[`wsu_${col}`] = wsuRow[col] ?? '';
                });
                cleanRows.push(rowData);
            } else {
                const errorRow = {
                    normalized_key: outcomesRow[outcomesNameField] ?? '',
                    missing_in: ambiguousSources.has(outcomesIndex) ? 'Ambiguous Match' : 'myWSU'
                };
                selectedColumns.outcomes.forEach(col => {
                    errorRow[`outcomes_${col}`] = outcomesRow[col] ?? '';
                });
                selectedColumns.wsu_org.forEach(col => {
                    errorRow[`wsu_${col}`] = '';
                });
                errorRows.push(errorRow);
            }
        });

        wsuOrg.forEach((wsuRow, wsuIndex) => {
            if (usedTargets.has(wsuIndex)) {
                return;
            }
            processedRows += 1;
            reportProgress('build_rows', processedRows, totalRows);
            const errorRow = {
                normalized_key: wsuRow[wsuNameField] ?? '',
                missing_in: 'Outcomes'
            };
            selectedColumns.outcomes.forEach(col => {
                errorRow[`outcomes_${col}`] = '';
            });
            selectedColumns.wsu_org.forEach(col => {
                errorRow[`wsu_${col}`] = wsuRow[col] ?? '';
            });
            errorRows.push(errorRow);
        });

        return { cleanRows, errorRows, selectedColumns, headerLabels };
    }

    const outcomesMap = buildKeyValueMap(outcomes, keyConfig.outcomes);
    const wsuMap = buildKeyValueMap(wsuOrg, keyConfig.wsu);
    const allKeys = new Set([...outcomesMap.keys(), ...wsuMap.keys()]);
    const outcomesEntries = Array.from(outcomesMap.entries()).map(([key, row]) => ({ key, row }));
    const wsuEntries = Array.from(wsuMap.entries()).map(([key, row]) => ({ key, row }));
    const usedOutcomes = new Set();
    const usedWsu = new Set();

    const allKeyList = Array.from(allKeys)
        .sort((a, b) => String(a).localeCompare(String(b)))
    reportProgress('build_rows', 0, allKeyList.length);
    allKeyList.forEach((key, index) => {
            let outcomesRow = outcomesMap.get(key) || null;
            let wsuRow = wsuMap.get(key) || null;
            let handledAsAmbiguous = false;

            if (outcomesRow) usedOutcomes.add(key);
            if (wsuRow) usedWsu.add(key);

            if (!outcomesRow && wsuRow && canNameMatch) {
                const match = findBestNameMatch(
                    wsuRow,
                    wsuNameField,
                    wsuLocationFields,
                    outcomesEntries,
                    outcomesNameField,
                    outcomesLocationFields,
                    threshold,
                    usedOutcomes,
                    ambiguityGap
                );
                if (match?.ambiguous) {
                    const errorRow = {
                        normalized_key: wsuRow[wsuNameField] ?? '',
                        missing_in: 'Ambiguous Match'
                    };
                    selectedColumns.outcomes.forEach(col => {
                        errorRow[`outcomes_${col}`] = '';
                    });
                    selectedColumns.wsu_org.forEach(col => {
                        errorRow[`wsu_${col}`] = wsuRow[col] ?? '';
                    });
                    errorRows.push(errorRow);
                    handledAsAmbiguous = true;
                } else if (match) {
                    outcomesRow = match.row;
                    usedOutcomes.add(match.key);
                }
            }
            if (outcomesRow && !wsuRow && canNameMatch) {
                const match = findBestNameMatch(
                    outcomesRow,
                    outcomesNameField,
                    outcomesLocationFields,
                    wsuEntries,
                    wsuNameField,
                    wsuLocationFields,
                    threshold,
                    usedWsu,
                    ambiguityGap
                );
                if (match?.ambiguous) {
                    const errorRow = {
                        normalized_key: outcomesRow[outcomesNameField] ?? '',
                        missing_in: 'Ambiguous Match'
                    };
                    selectedColumns.outcomes.forEach(col => {
                        errorRow[`outcomes_${col}`] = outcomesRow[col] ?? '';
                    });
                    selectedColumns.wsu_org.forEach(col => {
                        errorRow[`wsu_${col}`] = '';
                    });
                    errorRows.push(errorRow);
                    handledAsAmbiguous = true;
                } else if (match) {
                    wsuRow = match.row;
                    usedWsu.add(match.key);
                }
            }

            if (outcomesRow && wsuRow) {
                const rowData = {};
                if (canNameMatch) {
                    const nameScore = calculateNameSimilarity(
                        outcomesRow[outcomesNameField],
                        wsuRow[wsuNameField]
                    );
                    rowData.match_similarity = Math.round(nameScore * 1000) / 10;
                } else {
                    rowData.match_similarity = '';
                }
                selectedColumns.outcomes.forEach(col => {
                    rowData[`outcomes_${col}`] = outcomesRow[col] ?? '';
                });
                selectedColumns.wsu_org.forEach(col => {
                    rowData[`wsu_${col}`] = wsuRow[col] ?? '';
                });
                cleanRows.push(rowData);
            } else if ((!outcomesRow || !wsuRow) && !handledAsAmbiguous) {
                const errorRow = {
                    normalized_key: key,
                    missing_in: outcomesRow ? 'myWSU' : 'Outcomes'
                };
                selectedColumns.outcomes.forEach(col => {
                    errorRow[`outcomes_${col}`] = outcomesRow ? outcomesRow[col] ?? '' : '';
                });
                selectedColumns.wsu_org.forEach(col => {
                    errorRow[`wsu_${col}`] = wsuRow ? wsuRow[col] ?? '' : '';
                });
                errorRows.push(errorRow);
            }
            reportProgress('build_rows', index + 1, allKeyList.length);
        });

    return { cleanRows, errorRows, selectedColumns, headerLabels };
}

self.onmessage = (event) => {
    const { type, payload } = event.data || {};
    try {
        if (type === 'validate') {
            const { outcomes, translate, wsu_org, keyConfig, nameCompare } = payload;
            self.postMessage({ type: 'progress', stage: 'merge' });
            const merged = mergeData(outcomes, translate, wsu_org, keyConfig);
            self.postMessage({ type: 'progress', stage: 'validate' });
            const validatedData = validateMappings(
                merged,
                translate,
                outcomes,
                wsu_org,
                keyConfig,
                nameCompare,
                (processed, total) => {
                    self.postMessage({
                        type: 'progress',
                        stage: 'validate',
                        processed,
                        total
                    });
                }
            );
            const missingData = detectMissingMappings(outcomes, translate, keyConfig);
            const stats = generateSummaryStats(validatedData, outcomes, translate, wsu_org);
            self.postMessage({
                type: 'result',
                result: { validatedData, missingData, stats }
            });
            return;
        }
        if (type === 'generate') {
            const result = generateTranslationTableWorker(
                payload.outcomes,
                payload.wsu_org,
                payload.keyConfig,
                payload.nameCompare,
                payload.options,
                payload.selectedColumns,
                payload.keyLabels
            );
            self.postMessage({ type: 'result', result });
        }
    } catch (error) {
        self.postMessage({
            type: 'error',
            message: error?.message || String(error)
        });
    }
};
